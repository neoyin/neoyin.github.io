<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Pandas处理数据的基本操作">




  <meta name="keywords" content="python,pandas,">





    <link rel="alternate" href="/default" title="浮生若梦">




    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2021/06/04/pandas-process-data-basic/">


<meta name="description" content="#####  Series与DataFramePandas 的主要数据结构是Series（一维数据）与DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。Pandas 基于NumPy开发，可以与其它第三方科学计算支持库完美集成。  Series是一种类似与一维数组的对象，它由一组数据以及一组与之相关的数据便签（即索引）组成，仅由一组数据即可产生">
<meta name="keywords" content="python,pandas">
<meta property="og:type" content="article">
<meta property="og:title" content="Pandas处理数据的基本操作">
<meta property="og:url" content="http://yoursite.com/2021/06/04/pandas-process-data-basic/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="#####  Series与DataFramePandas 的主要数据结构是Series（一维数据）与DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。Pandas 基于NumPy开发，可以与其它第三方科学计算支持库完美集成。  Series是一种类似与一维数组的对象，它由一组数据以及一组与之相关的数据便签（即索引）组成，仅由一组数据即可产生">
<meta property="og:locale" content="cn">
<meta property="og:image" content="http://yoursite.com/assets/axis-20210906173548377.png">
<meta property="og:updated_time" content="2021-09-06T09:40:37.172Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pandas处理数据的基本操作">
<meta name="twitter:description" content="#####  Series与DataFramePandas 的主要数据结构是Series（一维数据）与DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。Pandas 基于NumPy开发，可以与其它第三方科学计算支持库完美集成。  Series是一种类似与一维数组的对象，它由一组数据以及一组与之相关的数据便签（即索引）组成，仅由一组数据即可产生">
<meta name="twitter:image" content="http://yoursite.com/assets/axis-20210906173548377.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




    





    





    <title> Pandas处理数据的基本操作 - 浮生若梦 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">浮生若梦</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
                
            </ul>
        
    </nav>

</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Pandas处理数据的基本操作
        
      </h1>

      <time class="post-time">
          Jun 4 2021
      </time>
    </header>



    
            <div class="post-content">
            <p>##### </p>
<h3 id="Series与DataFrame"><a href="#Series与DataFrame" class="headerlink" title="Series与DataFrame"></a>Series与DataFrame</h3><p>Pandas 的主要数据结构是Series（一维数据）与DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。Pandas 基于NumPy开发，可以与其它第三方科学计算支持库完美集成。</p>
<ul>
<li>Series是一种类似与一维数组的对象，它由一组数据以及一组与之相关的数据便签（即索引）组成，仅由一组数据即可产生最简单的Series。</li>
<li>DataFrame是一个表格型数据，含有一组有序的列，每一列可以是不同的类型值。DataFrame可以看成是由多个Series组成的字典，它们共用一个索引。</li>
</ul>
<p><strong>序列（Series）</strong>是一维结构，DataFrame的每一列都是一个序列（Series），序列结构只有行索引（row index），没有列名称（column name），但是序列有Name、dtype和index属性，其中Name属性是指序列的名称，dtype属性是指序列值的类型，index属性是序列的索引。序列存储的数据的数据类型是相同的。</p>
<p><strong>数据框（DataFrame）</strong>存储的是二维数据，数据框的结构由row和column构成，每一行都有一个row label，每一列都有一个column label，把row和column称作axis，把row label和column label称作axis label。通常情况下，column label 是文本类型，是列名称（column name），而row label是数值类型，也称作行索引（row index）。</p>
<p>对于这两个数据结构，有两个最基本的概念：轴（Axis）和标签（Label），对于二维数据结构，轴是指行和列，轴标签是指行的索引和列的名称，存储轴标签的数据结构是Index结构。每行都有一个索引，通过索引可以定位到该行；每列都有一个列名，通过列名可以定位到该列；通过行索引和列名称，可以唯一定位到一个唯一的数据点（cell）的数据值。</p>
<p><strong>轴标签</strong></p>
<p>存储轴标签的数据结构是Index，对于数据框，行标签（即行索引）和列名称（即列索引）是由Index对象存储的；对于序列，行索引是由Index对象存储的。索引对象是不可修改的，类似一个固定大小的数组。</p>
<p>对于索引，还可以通过序号来访问，序号是自动生成的，从0开始。</p>
<p>轴标签的最重要的作用是：</p>
<ul>
<li>唯一标识数据，用于定位数据</li>
<li>用于数据对齐</li>
<li>获取和设置数据集的子集。</li>
</ul>
<p>数据框和序列对象都有一个属性index，用于获取行标签，对于数据框，还有一个columns属性，用于获取列标签：</p>
<p><strong>Pandas库axis=0，axis= 1轴的用法</strong></p>
<p>刚学习Pandas，被axis=0或者axis=’index’，axis=1或者axis=’columns’给搞蒙了，甚至经常觉得书是不是写错了，有点反直觉。</p>
<p><img src="/assets/axis-20210906173548377.png" alt="img"></p>
<p>上图中：</p>
<ul>
<li>axis = 1：指的是沿着行求所有列的最大值，代表了横轴。</li>
<li>axis = 0：就是沿着列求所有行的平均值，代表了纵轴。</li>
</ul>
<h3 id="Pandas行、列、索引常规操作"><a href="#Pandas行、列、索引常规操作" class="headerlink" title="Pandas行、列、索引常规操作"></a>Pandas行、列、索引常规操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df.columns)  <span class="comment"># 输出列名</span></span><br><span class="line">df.columns = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  <span class="comment"># 重命名列名</span></span><br><span class="line">df = df[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]  <span class="comment"># 只选取想要的列</span></span><br><span class="line">df = df.transpose()  <span class="comment"># 行列转换</span></span><br><span class="line">df = df.T  <span class="comment"># 行列转换的简写方式</span></span><br><span class="line">df = df.set_index(<span class="string">'c'</span>)  <span class="comment"># 以c列作为索引</span></span><br><span class="line">df.reset_index() <span class="comment"># 重新变为默认的数值索引</span></span><br></pre></td></tr></table></figure>

<h3 id="Pandas中的loc和iloc"><a href="#Pandas中的loc和iloc" class="headerlink" title="Pandas中的loc和iloc"></a>Pandas中的loc和iloc</h3><p>loc与iloc的区别：</p>
<ul>
<li>.loc主要是基于标签(label)的，包括行标签(index)和列标签(columns)，即行名称和列名称，可以使用loc[index_name,col_name]</li>
<li>.iloc是基于位置的索引，利用元素在各个轴上的索引序号进行选择</li>
</ul>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .loc的用法</span></span><br><span class="line">df.loc[<span class="number">3</span>]  <span class="comment"># 选择index为3的一行，这里的’3’是index的名称，而不是序号</span></span><br><span class="line">df.loc[<span class="string">'a'</span>]  <span class="comment"># 获取index是a的某一行</span></span><br><span class="line">df.loc[[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]  <span class="comment"># 获取index为a,b,c的行</span></span><br><span class="line">df.loc[<span class="string">'c'</span>:<span class="string">'h'</span>]  <span class="comment"># 获取c到h行，包含c和h（左闭右闭）</span></span><br><span class="line">df.loc[df[<span class="string">'A'</span>] &gt; <span class="number">5</span>]  <span class="comment"># 筛选出所有A列&gt;5的行</span></span><br><span class="line">df.loc[df[<span class="string">'A'</span>] &gt; <span class="number">5</span>, [<span class="string">'C'</span>, <span class="string">'D'</span>]]  <span class="comment"># 筛选出所有A列&gt;5的行的C和D列</span></span><br><span class="line"><span class="comment"># .iloc的用法</span></span><br><span class="line">df.iloc[<span class="number">3</span>] <span class="comment"># 选择第四行，下标从0开始</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]] <span class="comment"># 选择第2、4、6行</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># 选择1~3行，和loc不同的是这里是左闭右开</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">3</span>,<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 选择1~3行,2~3列</span></span><br><span class="line">df.iloc[df[<span class="string">'A'</span>] &gt; <span class="number">5</span>]  <span class="comment"># 同上</span></span><br><span class="line">常用操作：</span><br><span class="line">X = df.iloc[:, :<span class="number">-1</span>]</span><br><span class="line">y = df.iloc[:, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Pandas与时间序列"><a href="#Pandas与时间序列" class="headerlink" title="Pandas与时间序列"></a>Pandas与时间序列</h3><p>依托 NumPy 的 datetime64、timedelta64 等数据类型，pandas 可以处理各种时间序列数据，还能调用 scikits.timeseries 等 Python 支持库的时间序列功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解析时间格式字符串、np.datetime64、datetime.datetime 等多种时间序列数据。</span></span><br><span class="line">dti = pd.to_datetime([<span class="string">'1/1/2018'</span>, np.datetime64(<span class="string">'2018-01-01'</span>), datetime.datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="comment"># 生成 DatetimeIndex、TimedeltaIndex、PeriodIndex 等定频日期与时间段序列。</span></span><br><span class="line">dti = pd.date_range(<span class="string">'2018-01-01'</span>, periods=<span class="number">3</span>, freq=<span class="string">'H'</span>)</span><br><span class="line"><span class="comment"># 处理、转换带时区的日期时间数据。</span></span><br><span class="line">dti = dti.tz_localize(<span class="string">'UTC'</span>)</span><br><span class="line">dti.tz_convert(<span class="string">'US/Pacific'</span>)</span><br><span class="line"><span class="comment"># 按指定频率重采样，并转换为时间序列。</span></span><br><span class="line">idx = pd.date_range(<span class="string">'2018-01-01'</span>, periods=<span class="number">5</span>, freq=<span class="string">'H'</span>)</span><br><span class="line">ts = pd.Series(range(len(idx)), index=idx)</span><br><span class="line">ts.resample(<span class="string">'2H'</span>).mean()</span><br><span class="line"><span class="comment"># 用绝对或相对时间差计算日期与时间。</span></span><br><span class="line">friday = pd.Timestamp(<span class="string">'2018-01-05'</span>)</span><br><span class="line">print(friday.day_name())</span><br><span class="line">saturday = friday + pd.Timedelta(<span class="string">'1 day'</span>)</span><br><span class="line">print(saturday.day_name())</span><br><span class="line">monday = friday + pd.offsets.BDay() <span class="comment"># 添加 1 个工作日，从星期五跳到星期一</span></span><br><span class="line">print(monday.day_name())</span><br><span class="line">针对时间索引数据的切片：</span><br><span class="line">ts[<span class="string">'2021'</span>] <span class="comment"># 查询整个2021年的</span></span><br><span class="line">ts[<span class="string">'2021-6'</span>] <span class="comment"># 查询 2021年6月的</span></span><br><span class="line">ts[<span class="string">'2021-6'</span>:<span class="string">'2021-10'</span>] <span class="comment"># 6月到10月的</span></span><br><span class="line">dft[<span class="string">'2013-1'</span>:<span class="string">'2013-2-28 00:00:00'</span>] <span class="comment"># 精确时间</span></span><br><span class="line">dft[<span class="string">'2013-1-15'</span>:<span class="string">'2013-1-15 12:30:00'</span>]</span><br><span class="line">dft.loc[<span class="string">'2013-01-05'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Pandas的数据类型"><a href="#Pandas的数据类型" class="headerlink" title="Pandas的数据类型"></a>Pandas的数据类型</h2><p>Pandas中主要的数据类型有：</p>
<ul>
<li>float</li>
<li>int</li>
<li>bool</li>
<li>datetime64[ns]</li>
<li>datetime64[ns, tz]</li>
<li>timedelta64[ns]</li>
<li>timedelta[ns]</li>
<li>category</li>
<li>object</li>
</ul>
<p>默认的数据类型是 int64 和 float64，文字类型是 object。</p>
<p>和 Python、NumPy 类型的对应关系：</p>
<table>
<thead>
<tr>
<th>Pandas 类型</th>
<th>Python 类型</th>
<th>NumPy类型</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>str or mixed</td>
<td>string_, unicode_, mixed types</td>
<td>文本或者混合数字</td>
</tr>
<tr>
<td>int64</td>
<td>int</td>
<td>int_, int8, int16, int32, int64, uint8, uint16, uint32, uint64</td>
<td>整型数字</td>
</tr>
<tr>
<td>float64</td>
<td>float</td>
<td>float_, float16, float32, float64</td>
<td>浮点数字</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td>bool_</td>
<td>True/False 布尔型</td>
</tr>
<tr>
<td>datetime64[ns]</td>
<td>nan</td>
<td>datetime64[ns]</td>
<td>日期时间</td>
</tr>
<tr>
<td>timedelta[ns]</td>
<td>nan</td>
<td>nan</td>
<td>两个时间之间的距离，时间差</td>
</tr>
<tr>
<td>category</td>
<td>nan</td>
<td>nan</td>
<td>有限文本值，枚举</td>
</tr>
</tbody></table>
<p>常用方法：</p>
<p>df.dtypes  # 各字段的数据类型</p>
<p>df[‘a’].dtype  # 某个字段的类型</p>
<p>df[‘a’].astype(float)  # 转换类型</p>
<h2 id="Pandas数据的获取与处理"><a href="#Pandas数据的获取与处理" class="headerlink" title="Pandas数据的获取与处理"></a>Pandas数据的获取与处理</h2><p>在日常的工作中，用的最多的是[使用Pandas读取Excel和CSV文件中的数据]。另外一个常用的操作是通过dict list转化为DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">d = [&#123;<span class="string">'points'</span>: <span class="number">50</span>, <span class="string">'time'</span>: <span class="string">'5:00'</span>, <span class="string">'year'</span>: <span class="number">2010</span>&#125;,</span><br><span class="line">&#123;<span class="string">'points'</span>: <span class="number">25</span>, <span class="string">'time'</span>: <span class="string">'6:00'</span>, <span class="string">'month'</span>: <span class="string">"february"</span>&#125;,</span><br><span class="line">&#123;<span class="string">'points'</span>: <span class="number">90</span>, <span class="string">'time'</span>: <span class="string">'9:00'</span>, <span class="string">'month'</span>: <span class="string">'january'</span>&#125;,</span><br><span class="line">&#123;<span class="string">'points_h1'</span>: <span class="number">20</span>, <span class="string">'month'</span>: <span class="string">'june'</span>&#125;]</span><br><span class="line">df = pd.DataFrame(d)</span><br></pre></td></tr></table></figure>

<p>除此之外，还有[Pandas中DataFrame的合并与连接]。[Pandas读取数据库数据]等常规操作。</p>
<h2 id="Pandas用于探索数据"><a href="#Pandas用于探索数据" class="headerlink" title="Pandas用于探索数据"></a>Pandas用于探索数据</h2><h3 id="查看数据基本情况"><a href="#查看数据基本情况" class="headerlink" title="查看数据基本情况"></a>查看数据基本情况</h3><p>查看、检查数据：</p>
<ul>
<li>head(n)：查看DataFrame对象的前n行</li>
<li>tail(n)：查看DataFrame对象的最后n行</li>
<li>shape()：查看行数和列数</li>
<li>info()：查看索引、数据类型和内存信息</li>
<li>describe()：查看数值型列的汇总统计<ul>
<li>describe(include=[np.number]) #指定数字类型</li>
<li>describe(include=[np.object]) #指定object类型</li>
<li>describe(include=[‘category’]) #指定列名</li>
</ul>
</li>
<li>value_counts(dropna=False)：查看Series对象的唯一值和计数</li>
<li>apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</li>
<li>unique：返回唯一值</li>
<li>corr()：返回列与列之间的相关性</li>
</ul>
<p>DataFrame.corr(method=’pearson’, min_periods=1)</p>
<p>参数说明：</p>
<ul>
<li>method：可选值为{‘pearson’, ‘kendall’, ‘spearman’}</li>
<li>min_periods：样本最少的数据量</li>
</ul>
<h3 id="异常数据的处理"><a href="#异常数据的处理" class="headerlink" title="异常数据的处理"></a>异常数据的处理</h3><p><strong>检查空值</strong></p>
<p>Pandas中存在两个检查空值的方法，pandas.DataFrame.isna() 和 pandas.DataFrame.isnull()，两个方法使用起来我完全一致。</p>
<p>使用示例：</p>
<ul>
<li>isna().sum()</li>
</ul>
<p><strong>值的替换</strong></p>
<p>示例：</p>
<ul>
<li>replace(‘-‘,’np.nan’)：用Null值替换’-‘</li>
<li>replace(1,’one’)：用‘one’代替所有等于1的值</li>
<li>replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替3</li>
</ul>
<p><strong>删除空值</strong></p>
<p>DataFrame.dropna(axis=0, how=’any’, thresh=None, subset=None, inplace=<strong>False</strong>)</p>
<p>参数说明：</p>
<ul>
<li>axis：它决定轴是行还是列。<ul>
<li>如果它是 0 或’index’，那么它将删除包含缺失值的行。</li>
<li>如果它是 1 或’column’，那么它将删除包含缺失值的列。默认情况下，它的值是 0</li>
</ul>
</li>
<li>how：这个参数决定函数如何删除行或列。它只接受两个字符串，可以是 all 或 all。默认情况下，它被设置为 any。<ul>
<li>any – 如果行或列中有任何空值，就会删除它。</li>
<li>all – 如果行或列中缺少所有值，则放弃该行或列</li>
</ul>
</li>
<li>thresh：它是一个整数，指定了防止行或列丢失的非缺失值的最少数量</li>
<li>subset：它是一个数组，其中有行或列的名称，用于指定删除程序</li>
<li>inplace：它是一个布尔值，如果设置为 True，将就地改变调用者 DataFrame。默认情况下，它的值是 False</li>
</ul>
<p>示例：</p>
<ul>
<li>dropna()：删除所有包含空值的行</li>
<li>dropna(axis=1)：删除所有包含空值的列</li>
<li>dropna(axis=1,thresh=n)：删除所有小于n个非空值的行</li>
</ul>
<p><strong>填充空值</strong></p>
<p>DataFrame.fillna(value=None, method=None, axis=None, inplace=<strong>False</strong>, limit=None, downcast=None)</p>
<p>参数说明：</p>
<ul>
<li>value: 用于填充空值的值</li>
<li>method: {‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, 默认None， pad/ffill表示向后填充空值，backfill/bfill表示向前填充空值</li>
<li>axis: 填充缺失值所沿的轴</li>
<li>inplace: boolean, 默认为False。若为True， 在原地填满</li>
<li>limit: int, 默认为None， 如果指定了方法， 则这是连续的NaN值的前向/后向填充的最大数量</li>
<li>downcast: dict, 默认None， 字典中的项为类型向下转换规则。</li>
</ul>
<p>示例：</p>
<ul>
<li>fillna(x)：用x替换DataFrame对象中所有的空值</li>
<li>fillna(s.mean())：用均值填充</li>
<li>fillna(s.median())：用中位数填充</li>
</ul>
<p><strong>去除重复</strong></p>
<p>DataFrame.drop_duplicates(subset=None, keep=’first’, inplace=<strong>False</strong>, ignore_index=<strong>False</strong>)</p>
<p>参数说明：</p>
<ul>
<li>subset： 输入要进行去重的列名，默认为None</li>
<li>keep： 可选参数有三个：‘first’、 ‘last’、 False， 默认值 ‘first’。其中，<ul>
<li>first表示： 保留第一次出现的重复行，删除后面的重复行。</li>
<li>last表示： 删除重复项，保留最后一次出现。</li>
<li>False表示： 删除所有重复项。</li>
</ul>
</li>
<li>inplace：布尔值，默认为False，是否直接在原数据上删除重复项或删除重复项后返回副本。</li>
</ul>
<p>示例：</p>
<p>df.drop_duplicates(subset=[‘A’,’B’],keep=’first’,inplace=<strong>True</strong>)</p>
<h3 id="数据的汇总统计"><a href="#数据的汇总统计" class="headerlink" title="数据的汇总统计"></a>数据的汇总统计</h3><p>Pandas中常用的统计函数：</p>
<ul>
<li>.count() #非空元素计算</li>
<li>.size() #包含NaN的计数</li>
<li>.min() #最小值</li>
<li>.max() #最大值</li>
<li>.idxmin() #最小值的位置，类似于R中的min函数</li>
<li>.idxmax() #最大值的位置，类似于R中的max函数</li>
<li>.quantile(0.1) #10%分位数</li>
<li>.sum() #求和</li>
<li>.mean() #均值</li>
<li>.median() #中位数</li>
<li>.mode() #众数</li>
<li>.var() #方差</li>
<li>.std() #标准差</li>
<li>.mad() #平均绝对偏差</li>
<li>.skew() #偏度</li>
<li>.kurt() #峰度</li>
</ul>
<p>当我们想查看DataFrame每列数据的时候，可以自定义一个函数方便的将统计指标汇总在一起(效果类似df.describe())：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.count(), x.min(), x.idxmin(), x.quantile(<span class="number">.25</span>), x.median(), x.quantile(<span class="number">.75</span>), x.mean(), x.max(), x.idxmax(),</span><br><span class="line">    x.mad(), x.var(), x.std(), x.skew(), x.kurt()],</span><br><span class="line">    index=[<span class="string">'总数'</span>, <span class="string">'最小值'</span>, <span class="string">'最小值位置'</span>, <span class="string">'25%分位数'</span>, <span class="string">'中位数'</span>, <span class="string">'75%分位数'</span>, <span class="string">'均值'</span>, <span class="string">'最大值'</span>, <span class="string">'最大值位数'</span>, <span class="string">'平均绝对偏差'</span>, <span class="string">'方差'</span>, <span class="string">'标准差'</span>, <span class="string">'偏度'</span>,<span class="string">'峰度'</span>])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    <span class="comment"># df = pd.DataFrame(status(d1))</span></span><br><span class="line">    df = pd.DataFrame(np.array([d1, d2, d3]).T, columns=[<span class="string">'x1'</span>, <span class="string">'x2'</span>, <span class="string">'x3'</span>])</span><br><span class="line">    df.apply(status)</span><br></pre></td></tr></table></figure>

<p><strong>Pandas中的分组groupby()</strong></p>
<p>最简单的方式，指定要进行分组的列和统计函数：</p>
<p>df.groupby(by=[‘col1’,’col2’]).size()</p>
<p>通常统计出来的值没有列名，通过此方法可指定列名：</p>
<p>df.groupby(by=[‘col1’, ‘col2’]).size().reset_index(name=’counts’)</p>
<p>groupby结合agg进行聚合：</p>
<p>df[[‘col1’, ‘col2’, ‘col3’, ‘col4’]].groupby([‘col1’, ‘col2’]).agg([‘mean’, ‘count’])</p>
<p>以上代码与以下SQL类似：</p>
<p>SELECT col1, col2, avg(col1), count(col2) FROM df GROUP BY col1, col2</p>
<p>添加列名：</p>
<p>key1 = df.groupby([“key1”], as_index=<strong>False</strong>)[“data1”].agg({“col_name”: “count”})</p>
<p><strong>Pandas中的排序sort_values()</strong></p>
<p>使用方法：</p>
<ul>
<li>sort_values(col1)：按照列col1排序数据，默认升序排列</li>
<li>sort_values(col2, ascending=False)：按照列col1降序排列数据</li>
<li>sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据</li>
</ul>
<p><strong>Pandas Dataframe的遍历</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row **<span class="keyword">in</span>** df.iterrows():</span><br><span class="line">    print(row[<span class="string">'c1'</span>], row[<span class="string">'c2'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="Pandas的apply函数"><a href="#Pandas的apply函数" class="headerlink" title="Pandas的apply函数"></a>Pandas的apply函数</h2><p>Pandas 的 apply() 方法是用来调用一个函数（Python method），让此函数对数据对象进行批量处理。</p>
<p>DataFrame.apply(func, axis=0, raw=<strong>False</strong>, result_type=None, args=(), **kwargs)</p>
<p>参数说明：</p>
<ul>
<li>func：function 应用于每个列或行的函数。</li>
<li>axis：{0 或 ‘index’, 1 或 ‘columns’}, 默认为 0<ul>
<li>0或‘index’：将功能应用于每列。</li>
<li>1或‘columns’：将功能应用于每一行。</li>
</ul>
</li>
<li>raw：确定是否将行或列作为Series或ndarray对象传递：<ul>
<li>False：将每个行或列作为 Series 传递给该函数。</li>
<li>True：传递的函数将改为接收ndarray对象。如果您仅应用NumPy缩减功能，则将获得更好的性能。</li>
</ul>
</li>
<li>result_type：{‘expand’, ‘reduce’, ‘broadcast’, None},这些仅在以下情况下起作用axis=1(列)：<ul>
<li>‘expand’：list-like结果将变成列。</li>
<li>‘reduce’：如果可能，则返回一个序列，而不是扩展list-like的结果。这与‘expand’相反。</li>
<li>‘broadcast’：结果将广播到DataFrame的原始形状，原始索引和列将保留。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ser.apply(fun) <span class="comment"># 自定义</span></span><br><span class="line">ser.apply(max) <span class="comment"># python 内置函数</span></span><br><span class="line">ser.apply(<span class="keyword">lambda</span> x: x*<span class="number">2</span>) <span class="comment"># lambda</span></span><br><span class="line">ser.apply(np.mean) <span class="comment"># numpy 等其他库的函数 ufunc</span></span><br><span class="line">ser.apply(pd.Series.first_valid_index) <span class="comment"># Pandas 自己的函数</span></span><br><span class="line">ser.apply(<span class="string">'count'</span>) <span class="comment"># Pandas 自己的函数</span></span><br><span class="line">ser.apply(<span class="string">'shape'</span>) <span class="comment"># Pandas 自己的属性</span></span><br><span class="line">ser.apply(<span class="string">'tan'</span>) <span class="comment"># numpy 的 ufunc 名</span></span><br><span class="line">\<span class="comment"># 多个函数</span></span><br><span class="line">ser.apply([sum, <span class="string">'count'</span>]) <span class="comment"># 相当于 .aggregate, 即.agg</span></span><br><span class="line">ser.apply(np.array([<span class="string">"sum"</span>, <span class="string">"mean"</span>]))</span><br><span class="line">ser.apply(&#123;<span class="string">'Q1'</span>:sum, <span class="string">'Q2'</span>:<span class="string">'count'</span>&#125;) <span class="comment"># 同上</span></span><br><span class="line">\<span class="comment">#SQL中row_number()的实现</span></span><br><span class="line">df[<span class="string">'Rank'</span>] = df.groupby(by=[<span class="string">'交易日期'</span>])[<span class="string">'交易时间'</span>].apply(<span class="keyword">lambda</span> x: x.rank(ascending=**<span class="literal">False</span>**))</span><br></pre></td></tr></table></figure>

<h2 id="Pandas平移函数shift-与diff"><a href="#Pandas平移函数shift-与diff" class="headerlink" title="Pandas平移函数shift()与diff()"></a>Pandas平移函数shift()与diff()</h2><h3 id="shift-函数"><a href="#shift-函数" class="headerlink" title="shift()函数"></a>shift()函数</h3><p>shift()函数主要的功能就是使数据框中的数据移动，若freq=None时，根据axis的设置，行索引数据保持不变，列索引数据可以在行上上下移动或在列上左右移动；若行索引为时间序列，则可以设置freq参数，根据periods和freq参数值组合，使行索引每次发生periods*freq偏移量滚动，列索引数据不会移动。</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0, fill_value=<no_default>)</no_default></p>
<p>参数说明：</p>
<ul>
<li>period：表示移动的幅度，可以是正数，也可以是负数，默认值是1,1就表示移动一次，注意这里移动的都是数据，而索引是不移动的，移动之后没有对应值的，就赋值为NaN。</li>
<li>freq： DateOffset, timedelta, or time rule string，可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。</li>
<li>axis： {0, 1, ‘index’, ‘columns’}，表示移动的方向，如果是0或者’index’表示上下移动，如果是1或者’columns’，则会左右移动。</li>
<li>fill_value：空行需要填充的数值</li>
</ul>
<h3 id="diff-函数"><a href="#diff-函数" class="headerlink" title="diff()函数"></a>diff()函数</h3><p>从官方的说明中已经很明确的可以知道其shift函数的关系为：df.diff() = df – df.shift()</p>
<p>DataFrame.diff(periods=1, axis=0)</p>
<p>参数说明：</p>
<ul>
<li>periods：移动的幅度，int类型，默认值为1。</li>
<li>axis：移动的方向，{0 or ‘index’, 1 or ‘columns’}，如果为0或者’index’，则上下移动，如果为1或者’columns’，则左右移动。</li>
</ul>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/python/">python</a>
          
            <a href="/tags/pandas/">pandas</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/09/04/nginx-python-jupyter/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Nginx配置Jupyter子路径</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/05/28/python-matplot-link/">
        <span class="next-text nav-default">Python数据可视化相关</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2012 -
    
    2021
    <span class="footer-author">Neo.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

    

  
  
  </body>
</html>
