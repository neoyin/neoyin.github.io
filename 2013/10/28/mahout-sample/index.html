<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Neo"><title>mahout入门示例 · 浮生若梦</title><meta name="description" content="# mahout入门示例
## 推荐系统简介### 运行第一个推荐引擎
\1. 创建示例数据1,101,5.01,102,3.01,103,2.52,101,2.02,102,2.52,103,5.02,104,2.03,101,2.53,104,4.03,105,4.53,107,5.04,101"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">浮生若梦</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>mahout入门示例</a></h3></div><div class="post-content"><p># mahout入门示例</p>
<p>## 推荐系统简介<br>### 运行第一个推荐引擎</p>
<p>\1. 创建示例数据<br>1,101,5.0<br>1,102,3.0<br>1,103,2.5<br>2,101,2.0<br>2,102,2.5<br>2,103,5.0<br>2,104,2.0<br>3,101,2.5<br>3,104,4.0<br>3,105,4.5<br>3,107,5.0<br>4,101,5.0<br>4,103,3.0<br>4,104,4.5<br>4,106,4.0<br>5,101,4.0<br>5,102,3.0<br>5,103,2.0<br>5,104,4.0<br>5,105,3.5<br>5,106,4.0</p>
<p>保存为文件intro.csv, 文件格式为逗号分隔的三列, 分别为user ID, item ID,<br>user对item的打分.假设这是一个用户对书本的打分记录,<br>经过一些学习之后，趋势就显现出来了。用户1和用户5具有相同的兴趣。他们都喜欢101这本书，对102的喜欢弱一些，对103的喜欢更弱。同<br>理，用户1和4具有相同的兴趣，他们都喜欢101和103，没有信息显示用户4喜欢102。另一方面，用户1和用户2的兴趣好像正好相反，用户1喜欢<br>101，但用户2讨厌101，用户1喜欢103而用户2正好相反。用户1和3的交集很少，只有101这本书显示了他们的兴趣。</p>
<p>\2. 创建一个maven工程<br>在pom文件中加入mahout的依赖</p>
<p>&lt;dependency&gt;<br>&lt;groupId&gt;org.apache.mahout&lt;/groupId&gt;<br>&lt;artifactId&gt;mahout-core&lt;/artifactId&gt;<br>&lt;version&gt;0.7&lt;/version&gt;<br>&lt;/dependency&gt;</p>
<p>下面是第一个推荐器的代码,</p>
<p>public static void main(String[] args) throws Exception {<br>String recsFile = “intro.csv”;<br>DataModel model = new FileDataModel(new File(recsFile)); // A</p>
<p>UserSimilarity similarity = new PearsonCorrelationSimilarity(model);<br>UserNeighborhood neighborhood = new NearestNUserNeighborhood(2,<br>similarity, model);</p>
<p>Recommender recommender = new GenericUserBasedRecommender(model,<br>neighborhood, similarity); // B</p>
<p>List&lt;RecommendedItem&gt; recommendations = recommender.recommend(1, 1); //<br>C</p>
<p>for (RecommendedItem recommendation : recommendations) {<br>System.out.println(recommendation);<br>}</p>
<p>}<br>A 加载数据文件<br>B 创建推荐系统引擎Create the recommender engine<br>C 对user1, 推荐一个item</p>
<a id="more"></a>

<p>我们可以总结一下每个模块所扮演的角色。DataModel存储了所有的偏好信息，提供了对user<br>和item信息的访问。UserSimiliarity提供了两个用户如何相似的概念，这可能基于很多可能的矩阵和计算之一。<br>UserNeighborhood定义了一个给定用户的用户组的概念。最终，一个推荐系统将这些模块组合在一起将items推荐给users和相关功能。</p>
<p>运行程序的输出应该是：RecommendedItem[item:104, value:4.257081]  </p>
<p>请求一个推荐结果并得到一个。推荐系统引擎将书104推荐给用户1。甚至，这样做是因为推荐系统引擎将用户1对书104的偏好是4.3，这是所有推荐结果的最高打分。  </p>
<p>这个结果并不算坏。107没有出现，本应该也是可以推荐的，但它只是和另一个具有不同爱好的user相关联。选104而不是106，因为104的打分高一些。还有，输出结果包含了一个用户1喜欢104的评估值<br>— 是介于用户4和5所表示的介于4.0和4.5的一个值。</p>
<p>### 评价推荐系统</p>
<p>大部分的推荐引擎通过给item评价打分来实现。所以，评价推荐引擎的一种方式是评价它的评估偏好值的质量<br>— 评价评估偏好和实际偏好的匹配度。  </p>
<p>“真实偏好”并不充分，没有人会知道你将来是否会喜欢一些新的item。推荐引擎可以通过设置一部分真实数据作为测试数据。这些测试数据偏好在训练集中并不展示偏好值<br>— 要求推荐系统对这些缺少偏好值的数据作出评估，并比较和实际值的差距。  </p>
<p>对于推荐系统产生一系列打分是很简单的。例如，计算评估值和实际值之间的平均距离，在这种方法下，分值越低越好。0.0表示非常好的评估<br>— 评估值和实际值根本没有差距。<br>均方根（root-mean-square）也是一种方法，也是分值越低越好。</p>
<p>下面是代码示例：</p>
<p>public static void main() throws Exception {<br>String recsFile = “intro.csv”;<br>DataModel model = new FileDataModel(new File(recsFile));<br>RandomUtils.useTestSeed(); // A</p>
<p>RecommenderEvaluator evaluator = new<br>AverageAbsoluteDifferenceRecommenderEvaluator();</p>
<p>RecommenderBuilder builder = new RecommenderBuilder() { // B<br>public Recommender buildRecommender(DataModel model) throws<br>TasteException {<br>UserSimilarity similarity = new PearsonCorrelationSimilarity(model);<br>UserNeighborhood neighborhood = new NearestNUserNeighborhood(2,<br>similarity, model);<br>return new GenericUserBasedRecommender(model, neighborhood,<br>similarity);<br>}<br>};<br>double score = evaluator.evaluate(builder, null, model, 0.7, 1.0); //<br>C<br>System.out.println(score);<br>}</p>
<p>大部分的操作发生在evaluate()这个方法中。内部，RecommenderEvaluator将数据划分为训练集和测试集，创建一个新的训练DataModel和推荐引擎测试，比价评估结果和实际结果。  </p>
<p>注意，没有将Recommender传给方法，这是因为在其内部，将基于创建的训练集的DataModel创建一个Recommender。所以调用者必须提供一个RecommenderBuilder对象用于从DataModel创建Recommender。</p>
<p>程序打印出了评估结果：一个表明推荐系统表现如何的打分。在这种情况下你能看到很简单的1.0。尽管评价器内部有很多随机方法去选择测试数据，<br>结果可能是一致的因为RandomUtils.useTestSeed()的使用，每次选取的随机数都一样。这只用于示例、单元测试来保证重复的结果。不<br>要在真是数据上用它。<br>AverageAbsoluteDifferenceRecommenderEvaluator  </p>
<p>基于AverageAbsoluteDifferenceRecommenderEvaluator实现，得到的这个值是什么含义？1.0意味着，平均意义上，推荐系统评估偏好和实际偏好的的距离是1.0.<br>..<br>1.0在1-5规模上并不大，但是我们的数据太少。如果数据集被随机划分结果可能不一样，因此训练、测试数据集可能每次跑都不一样。</p>
<p>### 评估准确率和召回率</p>
<p>借用更普遍的看法，我们接收经典的信息检索矩阵去评价推荐系统：准确率和召回率。这些是用于搜索引擎的术语，通过query从众多可能结果中返回最好结果集。  </p>
<p>一个搜索引擎不应该在靠前的结果中返回不相关的搜索结果，即使他致力于得到尽可能多的相关结果。”准确率”是指在靠前的结果中相关结果所占的比<br>例，当然这种相关是某种程度上我们定义的相关。”precision at<br>10″应该是从前10个结果中判断得到的准确率。“召回率”是指靠前的结果中相关结果占的比例。  </p>
<p>这些术语也可以应用到推荐系统中：准确率是靠前的推荐中好的推荐所占的比例，召回率是指出现在靠前推荐中好的推荐占整个好的推荐的比例。<br>public static void main(String[] args) throws Exception {<br>String recsFile = “intro.csv”;<br>DataModel model = new FileDataModel(new File(recsFile));</p>
<p>RandomUtils.useTestSeed();<br>RecommenderIRStatsEvaluator evaluator = new<br>GenericRecommenderIRStatsEvaluator();</p>
<p>RecommenderBuilder builder = new RecommenderBuilder() { // B<br>public Recommender buildRecommender(DataModel model) throws<br>TasteException {<br>UserSimilarity similarity = new PearsonCorrelationSimilarity(model);<br>UserNeighborhood neighborhood = new NearestNUserNeighborhood(2,<br>similarity, model);<br>return new GenericUserBasedRecommender(model, neighborhood,<br>similarity);<br>}<br>};<br>IRStatistics stats = evaluator.evaluate(builder, null, model, null, 2,<br>GenericRecommenderIRStatsEvaluator.CHOOSE_THRESHOLD, 1.0); // A<br>System.out.println(stats.getPrecision());<br>System.out.println(stats.getRecall());<br>}</p>
<p>评估方法最后会打印出这个推荐器的准确率和召回率.</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2013-10-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术流/" title="技术流">技术流 </a><a class="tag" href="/tags/mahout/" title="mahout">mahout </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2013/10/28/mahout-sample/,浮生若梦,mahout入门示例,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2013/10/30/hadoop-hdfs/" title="打造分布式文件系统--HDFS">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2013/10/28/hadoop-main-points/" title="打造分布式文件系统：Hadoop架构和设计要点[转]">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>